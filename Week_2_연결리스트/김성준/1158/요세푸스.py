# 1. 문제 이해
# 목표: (N, K)-요세푸스 순열을 구하는 프로그램 작성
# 	1) N: 사람의 수 (1번부터 N번까지)
# 	2) K: K번째 사람을 제거하는 규칙
# 	3) 원형 배열에서 한 명을 제거하면, 그다음 순서부터 K번째 사람을 제거
# 	4) 출력: 사람들이 제거된 순서를 < > 안에 출력
 
#  2. 예제 이해
#  입력 : 7 3
 
#  처리 과정
# 	1.초기 상태: [1, 2, 3, 4, 5, 6, 7] (사람 번호).
# 	2. 첫 번째 제거:
# 	    1) K번째(3번) 제거 → [1, 2, 4, 5, 6, 7].
# 		2) 시작 위치는 3번 이후.
# 	3. 두 번째 제거:
# 	    1) 다음 K번째(6번) 제거 → [1, 2, 4, 5, 7].
# 	4. 세 번째 제거:
# 	    1) 다음 K번째(2번) 제거 → [1, 4, 5, 7].
# 	5. 네 번째 제거:
# 	    1) 다음 K번째(7번) 제거 → [1, 4, 5].
# 	6. 다섯 번째 제거:
# 	    1) 다음 K번째(5번) 제거 → [1, 4].
# 	7. 여섯 번째 제거:
# 	    1) 다음 K번째(1번) 제거 → [4].
# 	8. 마지막 제거:
# 	    1) 4번 제거.

# 결과: <3, 6, 2, 7, 5, 1, 4>


# 3. 아이디어 추출
# 	1. 데이터 구조:
# 	   1) 원형 배열은 큐로 구현.
# 	   2) 큐를 활용해 K번째 사람을 제거하고, 제거 후에도 원형으로 이어질 수 있게 조작.
# 	2. K번째 사람 제거:
# 	    1) 큐에서 K번째 사람을 찾아 제거.
# 	    2) 제거된 위치 이후의 순서를 큐의 맨 앞으로 이동.
# 	3. 결과 저장:
# 	    1) 제거된 사람을 순서대로 리스트에 저장.
# 	4. 시간 복잡도:
# 	    1) 최대 N = 5000이므로 O(N * K) 접근법은 효율적이지 않음.
# 	    2) 큐의 순환을 효율적으로 처리하면 O(N)로 해결 가능.
 
 
#  4. 문제에 아이디어 접목
# 	1) 1번부터 N번까지 숫자를 큐에 넣는다.
# 	2) K번째 사람을 찾기 위해 K-1번 큐를 회전한다.
# 	3) 큐의 맨 앞 요소를 제거하고 결과 리스트에 추가한다.
# 	4) 위 과정을 큐가 빌 때까지 반복한다.
# 	5) 결과 리스트를 < >로 출력한다.

from collections import deque

def josephus(n, k):
    queue = deque(range(1, n + 1))  # 1번부터 N번까지
    result = []  # 제거된 순서를 저장할 리스트

    while queue:
        queue.rotate(-(k - 1))  # K-1만큼 왼쪽으로 회전
        result.append(queue.popleft())  # 맨 앞 사람 제거

    # 결과를 < > 형태로 반환
    return f"<{', '.join(map(str, result))}>"

# 입력 처리
n, k = map(int, input().split())
print(josephus(n, k))