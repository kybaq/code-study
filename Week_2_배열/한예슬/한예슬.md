## 배열 : 메모리 상에 원소를 연속적으로 배치한 자료구조

#### \* 특징

1. 임의 원소 접근 및 변경 : `시작 주소에서 k번째 원소의 위치를 직접 계산`할 수 있어, `O(1)`의 시간 복잡도로 접근 및 변경이 가능하다.

2. 메모리 효율성 : 추가적인 메모리 소모가 거의 없어 효율적이다.

3. 캐시 적중률 : 데이터가 연속적으로 배치되어 있어 캐시 적중률이 높다.

4. 메모리 할당 제약 : 연속된 메모리 공간을 필요로 하므로 할당에 제약이 있을 수 있다.

#### \* 배열에서의 주요 연산과 시간 복잡도

- 임의 위치 원소 확인 및 변경: O(1)

- 원소를 끝에 추가: O(1)

- 마지막 원소 제거: O(1)

- 임의 위치에 원소 추가: O(N) - 해당 위치 이후의 모든 원소를 한 칸씩 이동해야 한다.

- 임의 위치의 원소 제거: O(N) - 해당 위치 이후의 모든 원소를 한 칸씩 당겨와야 한다.

💠임의 위치에 원소를 추가하는 insert 함수

```js
// 배열의 끝에서부터 주어진 idx 위치까지 반복하며, 한 칸씩 뒤로 이동.
// 이동 후 idx에 새로운 값을 삽입
function insert(idx, num, arr) {
  for (let i = arr.length; i > idx; i--) {
    arr[i] = arr[i - 1];
  }
  arr[idx] = num;
}
```

💠임의 위치의 원소를 제거하는 erase 함수

```js
// idx 위치부터 배열 끝까지 반복하며, 한 칸씩 앞으로 이동.
// 마지막으로 배열의 길이를 length--로 줄이기.
function erase(idx, arr) {
  for (let i = idx; i < arr.length - 1; i++) {
    arr[i] = arr[i + 1];
  }
  arr.length--; // 배열 길이 줄이기
}
```

---

## 연결리스트 :

연결 리스트는 각 원소가 다음 원소의 위치를 가리키는 방식으로 구성된 자료구조. 메모리 상에서 원소들이 연속되지 않아도 되는 특징이 있으며, 배열과 달리 임의의 위치에 원소를 효율적으로 추가하거나 제거할 수 있다.

---

### 연결 리스트의 종류

1. **단일 연결 리스트 (Singly Linked List)**

   - 각 원소가 다음 원소의 주소만을 저장한다.

2. **이중 연결 리스트 (Doubly Linked List)**

   - 각 원소가 이전 및 다음 원소의 주소를 모두 저장하여 양방향 탐색이 가능하다.

3. **원형 연결 리스트 (Circular Linked List)**
   - 마지막 원소가 첫 번째 원소를 가리켜 원형 구조를 이룬다.

---

### 연결 리스트의 특징

- **k번째 원소 접근**:  
  k번째 원소에 접근하려면 첫 번째 원소부터 순차적으로 이동해야 하므로 `O(k)`의 시간이 소요됨.

- **임의 위치에 원소 추가/제거**:  
  해당 위치의 주소를 알고 있다면, 원소의 추가나 제거는 `O(1)`의 시간에 수행할 수 있다.

- **메모리 배치**:  
  원소들이 메모리 상에 불연속적으로 배치되므로, 캐시 적중률(Cache hit rate)이 낮을 수 있지만, 메모리 할당이 유연하다.
