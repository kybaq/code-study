### 배열 : 메모리 상에 원소를 연속적으로 배치한 자료구조

#### \* 특징

1. 임의 원소 접근 및 변경 : `시작 주소에서 k번째 원소의 위치를 직접 계산`할 수 있어, `O(1)`의 시간 복잡도로 접근 및 변경이 가능하다.

2. 메모리 효율성 : 추가적인 메모리 소모가 거의 없어 효율적이다.

3. 캐시 적중률 : 데이터가 연속적으로 배치되어 있어 캐시 적중률이 높다.

4. 메모리 할당 제약 : 연속된 메모리 공간을 필요로 하므로 할당에 제약이 있을 수 있다.

#### \* 배열에서의 주요 연산과 시간 복잡도

- 임의 위치 원소 확인 및 변경: O(1)

- 원소를 끝에 추가: O(1)

- 마지막 원소 제거: O(1)

- 임의 위치에 원소 추가: O(N) - 해당 위치 이후의 모든 원소를 한 칸씩 이동해야 한다.

- 임의 위치의 원소 제거: O(N) - 해당 위치 이후의 모든 원소를 한 칸씩 당겨와야 한다.

💠임의 위치에 원소를 추가하는 insert 함수

```js
// 배열의 끝에서부터 주어진 idx 위치까지 반복하며, 한 칸씩 뒤로 이동.
// 이동 후 idx에 새로운 값을 삽입
function insert(idx, num, arr) {
  for (let i = arr.length; i > idx; i--) {
    arr[i] = arr[i - 1];
  }
  arr[idx] = num;
}
```

💠임의 위치의 원소를 제거하는 erase 함수

```js
// idx 위치부터 배열 끝까지 반복하며, 한 칸씩 앞으로 이동.
// 마지막으로 배열의 길이를 length--로 줄이기기.
function erase(idx, arr) {
  for (let i = idx; i < arr.length - 1; i++) {
    arr[i] = arr[i + 1];
  }
  arr.length--; // 배열 길이 줄이기
}
```
