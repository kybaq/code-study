#문제 이해
# 	1) N×M 크기의 미로가 주어지고 1은 이동할 수 있는 칸이고 0은 이동할 수 없는 벽
# 	2) (1,1) → (N,M)까지 최단 경로를 구해야됨
# 	3) 인접한 칸(상하좌우)으로만 이동 가능
# 	4) 이동한 칸의 개수를 출력해야 하며, 출발점과 도착점도 포함됨

#예제 이해

# 입력
# 4 6
# 101111
# 101010
# 101011
# 111011

# 미로 표현
# 1  0  1  1  1  1  
# 1  0  1  0  1  0  
# 1  0  1  0  1  1  
# 1  1  1  0  1  1  

# 1) (1,1)에서 (4,6)까지 최단 경로를 찾아야됨
# 2) 15칸을 지나야 도착할 수 있음

# 아이디어 추출
# 	1) 최단 거리 탐색이므로 BFS를 사용
# 	2) queue를 사용하여 현재 위치에서 상하좌우로 이동하며 거리 값을 증가시킴
# 	3) 방문한 칸은 다시 방문하지 않음
# 	4) 목표 지점 (N,M)에 도착하면 해당 칸의 거리 값을 출력
 
 
# 아이디어를 문제에 적용
# 	1)	미로를 2차원 리스트로 저장하고, BFS 탐색을 위해 deque를 사용
# 	2)	(1,1) => (N,M)까지 최단 거리를 기록하면서 진행
# 	3)	방문 체크를 따로 두지 않고, 방문한 칸의 값을 거리로 갱신하면서 진행
# 	4)	(N,M)에 도착하면 현재까지 이동한 거리를 출력
 
import sys
from collections import deque

# 입력 받기
N, M = map(int, sys.stdin.readline().split())
maze = [list(map(int, list(sys.stdin.readline().strip()))) for _ in range(N)]

# 이동 방향 (상, 하, 좌, 우)
dx = [-1, 1, 0, 0]
dy = [0, 0, -1, 1]

# BFS 초기 설정
queue = deque([(0, 0)])  # 시작점 (0,0)에서 BFS 시작

while queue:
    x, y = queue.popleft()

    # 목표 지점 (N-1, M-1)에 도착하면 종료
    if x == N-1 and y == M-1:
        print(maze[x][y])  # 최단 거리 출력
        break

    # 상, 하, 좌, 우 이동
    for d in range(4):
        nx, ny = x + dx[d], y + dy[d]

        # 미로 범위를 벗어나지 않고, 이동할 수 있는 칸(1)일 경우 이동
        if 0 <= nx < N and 0 <= ny < M and maze[nx][ny] == 1:
            queue.append((nx, ny))
            maze[nx][ny] = maze[x][y] + 1  # 이동 거리를 업데이트