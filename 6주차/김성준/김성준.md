<!--

재귀란?
	1) 자기 자신을 호출하는 함수
	2) 함수 내부에서 자기 자신을 다시 호출하는 방식으로 문제를 해결하는 기법
	3) 대표적으로 팩토리얼, 피보나치 수열, 하노이의 탑, 분할 정복 등에 활용됨

재귀의 기본 원리
def recursive_function(입력):
    if 종료 조건(기본 케이스):
        return 특정 값  # 종료 조건을 만나면 재귀 종료
    return recursive_function(새로운 입력)  # 재귀 호출

	1) 반드시 종료 조건이 필요
	2) 무한 루프 방지를 위해 기본(base) 케이스가 필요
	3) 입력을 점점 줄이며 문제를 단순화
	4) 문제를 작은 단위로 쪼개면서 최종적으로 기본 케이스에 도달하도록 설계

재귀를 사용해야 하는 경우
1) 문제를 작은 문제로 나누어 해결할 수 있을 때
2) 반복문으로 풀기 어렵고, 자연스럽게 재귀적 구조를 가질 때
3) 분할 정복, 백트래킹, DFS 등의 문제에서 활용할 때 유용

재귀의 시간 복잡도 분석
	1) O(N) 시간 복잡도
	2) factorial(n)의 경우 n번 호출되므로 O(N)
	3) 스택 오버플로(Stack Overflow) 위험
	4) 재귀 호출이 너무 깊어지면 메모리 초과 발생 가능
	5) 이를 방지하려면 메모이제이션(Memoization) 또는 반복문 활용

재귀를 효율적으로 사용하기 위한 팁
1) 반드시 종료 조건을 명확하게 설정 (없으면 무한 루프)
2) 메모이제이션(Memoization) 활용 (중복 호출 방지)
3) 재귀 깊이가 깊어지면 sys.setrecursionlimit() 조정
4) 반복문으로 해결 가능한 경우, 가능하면 반복문 사용

재귀의 활용 예시
분할 정복 (Divide and Conquer) => 이진 탐색, 거듭제곱
DFS (깊이 우선 탐색) => 그래프 탐색
백트래킹 (Backtracking) => N-Queen, 부분집합
하노이의 탑 문제
피보나치 수열 (DP + 재귀 최적화)
-->

<!--
백트래킹(Backtracking) 이란?
	1) 모든 경우의 수를 탐색하는 알고리즘 중 하나로, 불필요한 경로를 미리 차단(가지치기, Pruning)하여 탐색 속도를 개선하는 기법
	2) 해를 찾을 가능성이 없는 경로를 더 이상 탐색하지 않고 되돌아가는(Backtrack) 방식으로 동작
	3) DFS(깊이 우선 탐색, Depth-First Search) 기반의 탐색 기법
	4) 가능한 모든 경우를 검사하되 가지치기를 통해 탐색 공간을 줄이는 것이 핵심


백트래킹의 동작 원리
	1)현재 상태에서 가능한 모든 후보군을 확인
	2) 유효한 후보인지 검사하여 조건을 만족하는 경우에만 탐색을 진행
	3) 조건을 만족하지 않으면 해당 경로를 더 이상 탐색하지 않고 백트래킹(되돌아감)함
	4) 조건을 만족하면 다음 단계(재귀)로 넘어가고, 최종적으로 정답을 찾으면 저장하거나 카운트
	5) 모든 탐색이 끝나면 이전 단계로 돌아가 새로운 경우를 탐색
	6) 모든 경우를 다 탐색하지만, 가능성이 없는 경우는 빠르게 포기하면서 최적의 해를 찾는 방식


백트래킹이 사용되는 대표적인 문제 유형
- N-Queen 문제: 체스판에서 N개의 퀸을 서로 공격할 수 없도록 배치하는 문제
- 순열 생성: 주어진 숫자나 문자의 모든 가능한 조합을 생성
- 조합 문제: 특정 조건을 만족하는 부분집합을 찾는 문제
- 부분 집합(Subset) 생성: 모든 가능한 부분 집합을 생성하는 문제
- 수식의 괄호 검사: 올바른 괄호 조합을 찾는 문제
- 미로 탐색(Maze Solving): 출구를 찾는 최적의 경로 탐색
- 그래프 탐색 문제: 특정 조건을 만족하는 경로 탐색 문제


백트래킹 문제 해결 접근 방식
	1) 문제의 상태(State) 정의: 현재 탐색의 위치나 진행 상태를 정의해야 한다.
	2) 가능한 모든 후보군 생성: 현재 상태에서 탐색할 수 있는 모든 후보를 생성한다.
	3) 유효성 검사(Pruning, 가지치기): 유효하지 않은 후보는 제외하여 불필요한 탐색을 방지한다.
	4) 재귀 호출(DFS 방식 탐색): 조건을 만족하면 재귀적으로 다음 단계로 탐색을 진행한다.
	5) 목표 상태 도달 시 정답 처리: 정답을 찾으면 저장하거나 카운트한다.
	6) 백트래킹 수행(원상 복구): 재귀 호출 이후 이전 상태로 되돌아가 다음 후보군을 탐색한다.


백트래킹을 사용할 때 고려해야 할 점
	1) 시간 복잡도: 백트래킹은 일반적으로 `O(N!)` 또는 `O(2^N)`의 시간 복잡도를 가지므로, 가지치기(Pruning)를 적극 활용해야 함
	2) 재귀 깊이: 재귀 호출이 많아질 경우 `RecursionError`가 발생할 수 있으므로, `sys.setrecursionlimit()`을 활용해 제한을 늘려야됨
	3) 불필요한 탐색 최소화: 백트래킹을 할 때 불필요한 탐색을 최소화하는 전략을 활용해야 성능이 향상됨


백트래킹과 다른 탐색 기법 비교
| 탐색 기법 | 설명 | 장점 | 단점 |
|----------|------|------|------|
| 완전 탐색(Brute Force) | 가능한 모든 경우를 탐색 | 단순하고 구현이 쉬움 | 비효율적(O(N!)) |
| 백트래킹(Backtracking) | 불필요한 경로를 가지치기하며 탐색 | 탐색 속도 개선 | 가지치기 로직이 필요 |
| DP(Dynamic Programming) | 이전 결과를 저장하며 최적 해 탐색 | 효율적 | 상태 정의가 어려움 |
| 그리디(Greedy) | 현재 최적의 선택을 진행 | 빠름 | 최적해를 보장하지 않음 |

 -->
