# 문제 이해
# 지민이는 양방향 순환 큐를 가지고 있으며, N개의 원소가 있음
# 특정 위치의 원소를 뽑아내는데, 연산은 다음과 같음:
# 1) 첫 번째 원소를 뽑아냄 → 단순히 큐에서 pop
# 2) 왼쪽으로 한 칸 이동 → 큐를 한 칸 왼쪽으로 회전
# 3) 오른쪽으로 한 칸 이동 → 큐를 한 칸 오른쪽으로 회전
# 목표:
# 특정 위치의 원소를 뽑아내는 데 드는 2번과 3번 연산의 최솟값 계산
 
 
#예제 이해
# 입력:
# 10 3
# 1 2 3

# 큐: 1, 2, 3, 4, 5, 6, 7, 8, 9, 10
# 뽑아내려는 순서: 1 → 2 → 3
# 풀이 과정:
# 1은 큐의 첫 번째 원소이므로 바로 뽑아낼 수 있음 => 연산 0번 m
# 2는 뽑아내려는 위치로 이미 왼쪽으로 정렬되어 있음 => 연산 0번
# 3도 동일 => 연산 0번

# 출력: 
# 0     
 
#아이디어 추출
# 큐에서 원소를 뽑아내기 위해 연산을 최소화해야 함
# 특정 원소를 뽑아내기 위해 왼쪽으로 회전하거나 오른쪽으로 회전해야 함:
# 1) 왼쪽으로 회전 → target의 인덱스를 기준으로
# 2) 오른쪽으로 회전 → 큐 길이 - target의 인덱스를 기준으로
# 각 원소를 뽑을 때:
# 1) 왼쪽 회전 횟수와 오른쪽 회전 횟수 중 최솟값을 선택
# 2) 선택된 연산만큼 큐를 회전시켜 원소를 뽑아냄
 
#아이디어를 문제에 적용
# 큐를 deque로 초기화하여 양방향 회전 연산을 쉽게 수행
# 뽑아낼 원소의 위치를 하나씩 처리하며, 최솟값 계산
# 각 연산마다 큐를 업데이트하고, 총 연산 횟수를 누적


 
from collections import deque

n, m = map(int, input().split())  # 큐의 크기 N과 뽑아내려는 수의 개수 M 입력
targets = list(map(int, input().split()))  # 뽑아내려는 수의 위치를 리스트로 저장
queue = deque(range(1, n + 1))  # 1부터 N까지의 숫자를 큐로 초기화

operations = 0  # 총 연산 횟수를 저장할 변수

for target in targets:
    while True:
        if queue[0] == target:  # 타겟 숫자가 큐의 맨 앞에 있을 경우
            queue.popleft()  # 해당 숫자를 뽑아내고 반복 종료
            break
        else:
            # 왼쪽 회전과 오른쪽 회전 중 최소 연산을 선택
            if queue.index(target) <= len(queue) // 2:  # 타겟이 큐의 앞쪽에 가까운 경우
                queue.rotate(-1)  # 왼쪽으로 한 칸 회전
            else:  # 타겟이 큐의 뒤쪽에 가까운 경우
                queue.rotate(1)  # 오른쪽으로 한 칸 회전
            operations += 1  # 회전 연산 횟수 증가

print(operations)