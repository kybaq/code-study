#1. 문제 이해
# 주어진 프로세스의 우선순위 큐에서 특정 프로세스가 몇 번째로 실행되는지 구하기
# 작동원리
	# 큐에서 프로세스를 꺼냄
	# 현재 프로세스보다 높은 우선순위가 있다면 다시 큐에 넣음
	# 높은 우선순위가 없다면 실행(종료)

#2. 예제 이해
# 예제1
# 	입력: priorities = [2, 1, 3, 2], location = 2
# 	처리 과정:
# 		1) 초기 상태: [2, 1, 3, 2] → index 2가 목표
# 		2) 첫 번째: 2를 꺼냄 → 우선순위 3이 있으므로 다시 큐에 넣음
# 		3) 두 번째: 1을 꺼냄 → 우선순위 3이 있으므로 다시 큐에 넣음
# 		4) 세 번째: 3을 꺼냄 → 실행
# 		5) 네 번째: 2를 꺼냄 → 실행
#   출력: 1

# 예제2
# 	입력: priorities = [1, 1, 9, 1, 1, 1], location = 0
# 	처리 과정:
# 		1) 초기 상태: [1, 1, 9, 1, 1, 1] → index 0이 목표
# 		2) 첫 번째: 1을 꺼냄 → 우선순위 9가 있으므로 다시 큐에 넣음
# 		3) 두 번째: 1을 꺼냄 → 우선순위 9가 있으므로 다시 큐에 넣음
# 		4) 세 번째: 9를 꺼냄 → 실행
# 		5) 네 번째: 1을 꺼냄 → 실행
# 		6) 다섯 번째: 1을 꺼냄 → 실행
# 		7) 여섯 번째: 1(A)을 꺼냄 → 실행
#   출력: 5

#3. 아이디어 정리
# 1. 우선순위 확인:
#   큐에서 현재 프로세스를 꺼내고, 나머지 중 더 높은 우선순위가 있으면 다시 큐에 넣음
# 2. 위치 추적:
#   프로세스의 위치를 함께 저장하여, 목표 프로세스가 언제 실행되는지 확인
# 3. 효율성 고려:
#   우선순위를 확인하는 데 최대 O(n), 이를 반복하므로 총 O(n^2)

#4. 아이디어를 문제에 적용
# 	1. 초기화:
#      각 프로세스를 (우선순위, 인덱스)로 저장하여 위치 추적
#   2. 큐 처리:
#     1) 큐에서 프로세스를 꺼낸 뒤, 높은 우선순위가 있다면 다시 삽입
#     2) 높은 우선순위가 없으면 실행
#   3. 목표 프로세스 실행 시 종료

from collections import deque

def solution(priorities, location):
    # 1. 초기화: 각 프로세스를 (우선순위, 인덱스)로 저장하여 위치 추적
    queue = deque([(priority, idx) for idx, priority in enumerate(priorities)]) #priorities 리스트의 각 원소를 (우선순위, 인덱스) 형태로 저장하여 큐(queue) 생성
    order = 0  # 실행 순서를 추적하는 변수 초기화

    # 2. 큐 처리
    while queue:
        current = queue.pop()  # 큐의 첫 번째 프로세스를 꺼냄
        # 2-1) 높은 우선순위가 있다면 다시 큐에 삽입
        if any(current[0] < q[0] for q in queue):  # 현재 프로세스보다 높은 우선순위가 있는지 확인
            queue.append(current)  # 다시 큐의 끝에 삽입
        else:
            # 2-2) 높은 우선순위가 없으면 실행
            order += 1  # 실행 순서를 증가
            if current[1] == location:  # 목표 프로세스가 실행된 경우
                return order  # 실행 순서를 반환